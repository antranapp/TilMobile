import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'package:provider/provider.dart';
import 'package:git_bindings/git_bindings.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:function_types/function_types.dart';
import 'package:path/path.dart' as p;

import 'package:til/apis/git_host_factory.dart';

import 'package:til/ui/screen/git_setup/git_host_setup_type.dart';
import 'package:til/utils/utils.dart';
import 'package:til/utils/logger.dart';
import 'package:til/settings/settings.dart';
import 'package:til/state/state_container.dart';

import 'git_host_choice_page.dart';
import 'git_clone_url_page.dart';
import 'git_host_setup_key_choice_page.dart';
import 'git_host_setup_auto_configure_page.dart';
import 'git_host_auto_configure_choice_page.dart';

class SettingGitSetupScreen extends StatefulWidget {

    final Func0<void> onCompletedFunction;

    SettingGitSetupScreen(this.onCompletedFunction);

    @override
    State<StatefulWidget> createState() => _SettingGitSetupScreen();
}

enum PageChoice0 { Unknown, KnownProvider, CustomProvider }
enum PageChoice1 { Unknown, Manual, Auto }
enum KeyGenerationChoice { Unknown, AutoGenerated, UserProvided }

class _SettingGitSetupScreen extends State<SettingGitSetupScreen> {

    var _pageCount = 1;

    var _pageChoice = [
        PageChoice0.Unknown,
        PageChoice1.Unknown
    ];

    var _keyGenerationChoice = KeyGenerationChoice.Unknown;
    var _gitHostType = GitHostType.Unknown;
    var _gitCloneUrl = "";
    var gitCloneErrorMessage = "";
    var publicKey = "";

    var pageController = PageController();
    int _currentPageIndex = 0;

    Widget _buildPage(BuildContext context, int position) {
        assert(_pageCount >= 1);

        switch (position) {
            case 0: {
                return GitHostChoicePage(
                    onKnownGitHost: (GitHostType gitHostType) {
                        setState(() {
                            _gitHostType = gitHostType;
                            _pageChoice[0] = PageChoice0.KnownProvider;
                            _pageCount = position + 2;
                            _nextPage();
                        });
                    },
                    onCustomGitHost: () {
                        setState(() {
                            _pageChoice[0] = PageChoice0.CustomProvider;
                            _pageCount = position + 2;
                            _nextPage();
                        });
                    },
                );
            }
            break;

            case 1: {
                assert(_pageChoice[0] != PageChoice0.Unknown);

                if (_pageChoice[0] == PageChoice0.CustomProvider) {
                    return GitCloneUrlPage(
                        doneFunction: (String sshUrl) {
                            setState(() {
                                _gitCloneUrl = sshUrl;

                                _pageCount = position + 2;
                                _nextPage();
                            });
                        },
                        initialValue: _gitCloneUrl,
                    );
                }

                return GitHostAutoConfigureChoicePage(
                    onDone: (GitHostSetupType setupType) {
                        if (setupType == GitHostSetupType.Manual) {
                            setState(() {
                                _pageCount = position + 2;
                                _pageChoice[1] = PageChoice1.Manual;
                                _nextPage();
                            });
                        } else if (setupType == GitHostSetupType.Auto) {
                            setState(() {
                                _pageCount = position + 2;
                                _pageChoice[1] = PageChoice1.Auto;
                                _nextPage();
                            });
                        }
                    },
                );
            }
            break;

            case 2: {
                if (_pageChoice[0] == PageChoice0.CustomProvider) {
                    return GitHostSetupKeyChoice(
                        onGenerateKeys: () {
                            setState(() {
                                _keyGenerationChoice = KeyGenerationChoice.AutoGenerated;
                                _pageCount = position + 2;

                                _nextPage();
                                _generateSshKey(context);
                            });
                        },
                        onUserProvidedKeys: () {
                            setState(() {
                                _keyGenerationChoice = KeyGenerationChoice.UserProvided;
                                _pageCount = position + 2;
                                _nextPage();
                            });
                        },
                    );
                }

                assert(_pageChoice[1] != PageChoice1.Unknown);

                if (_pageChoice[1] == PageChoice1.Manual) {
                    return GitCloneUrlKnownProviderPage(
                        doneFunction: (String sshUrl) {
                            setState(() {
                                _pageCount = position + 2;
                                _gitCloneUrl = sshUrl;

                                _nextPage();
                            });
                        },
                        launchCreateUrlPage: _launchCreateRepoPage,
                        gitHostType: _gitHostType,
                        initialValue: _gitCloneUrl,
                    );
                } else if (_pageChoice[1] == PageChoice1.Auto) {
                    return GitHostSetupAutoConfigure(
                        gitHostType: _gitHostType,
                        onDone: (String gitCloneUrl) {
                            setState(() {
                                _gitCloneUrl = gitCloneUrl;
                                _pageCount = position + 2;

                                _nextPage();
                                _startGitClone(context);
                            });
                        },
                    );
                }
            }
            break;
        }
    }

    @override
    Widget build(BuildContext context) {
        return Center(
            child: Text('GitSetupScreen'),
        );
    }

    // Private helpers

    void _nextPage() {
        pageController.nextPage(
            duration: const Duration(milliseconds: 200),
            curve: Curves.easeIn,
        );
    }

    void _startGitClone(BuildContext context) async {
        setState(() {
            gitCloneErrorMessage = "";
        });

        var stateContainer = Provider.of<StateContainer>(context);
        var appState = stateContainer.appState;
        var basePath = appState.gitBaseDirectory;

        // Just in case it was half cloned because of an error
        await _removeExistingClone(basePath);

        String repoPath = p.join(basePath, "journal");
        String error;
        try {
            Log.d("Cloning " + _gitCloneUrl);
            await GitRepo.clone(repoPath, _gitCloneUrl);
        } on GitException catch (e) {
            error = e.cause;
        }

        if (error != null && error.isNotEmpty) {
            setState(() {
                gitCloneErrorMessage = error;
            });
            return;
        }

        //
        // Add a GitIgnore file. This way we always at least have one commit
        // It makes doing a git pull and push easier
        //
        var gitIgnorePath = p.join(repoPath, ".gitignore");
        var ignoreFile = File(gitIgnorePath);
        if (!ignoreFile.existsSync()) {
            ignoreFile.createSync();

            var repo = GitRepo(
                folderPath: repoPath,
                authorName: Settings.instance.gitAuthor,
                authorEmail: Settings.instance.gitAuthorEmail,
            );
            await repo.add('.gitignore');
            await repo.commit(message: "Add gitignore file");
        }

        Navigator.pop(context);
        //widget.onCompletedFunction();
    }

    void _generateSshKey(BuildContext context) {
        if (publicKey.isNotEmpty) {
            return;
        }

        var comment = "GitJournal-" +
            Platform.operatingSystem +
            "-" +
            DateTime.now().toIso8601String().substring(0, 10); // only the date

        generateSSHKeys(comment: comment).then((String publicKey) {
            setState(() {
                this.publicKey = publicKey;
                Log.d("PublicKey: " + publicKey);
                _copyKeyToClipboard(context);
            });
        });
    }

    void _copyKeyToClipboard(BuildContext context) {
        Clipboard.setData(ClipboardData(text: publicKey));
        showSnackbar(context, "Public Key copied to Clipboard");
    }

    void _launchCreateRepoPage() async {
        assert(_gitHostType != GitHostType.Unknown);

        try {
            if (_gitHostType == GitHostType.GitHub) {
                await launch("https://github.com/new");
            } else if (_gitHostType == GitHostType.GitLab) {
                await launch("https://gitlab.com/projects/new");
            }
        } catch (err, stack) {
            // FIXME: Error handling?
            Log.d("_launchCreateRepoPage: " + err.toString());
            Log.d(stack.toString());
        }
    }

    Future _removeExistingClone(String baseDirPath) async {
        var baseDir = Directory(p.join(baseDirPath, "journal"));
        var dotGitDir = Directory(p.join(baseDir.path, ".git"));
        bool exists = dotGitDir.existsSync();
        if (exists) {
            Log.d("Removing " + baseDir.path);
            await baseDir.delete(recursive: true);
            await baseDir.create();
        }
    }
}