import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'package:dots_indicator/dots_indicator.dart';
import 'package:provider/provider.dart';
import 'package:git_bindings/git_bindings.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:function_types/function_types.dart';
import 'package:path/path.dart' as p;

import 'package:til/apis/git/git_host_factory.dart';

import 'package:til/ui/screen/git_setup/setup_type.dart';
import 'package:til/utils/utils.dart';
import 'package:til/utils/logger.dart';
import 'package:til/settings/settings.dart';
import 'package:til/state/state_container.dart';

import 'provider_selection_page.dart';
import 'clone_url_page.dart';
import 'ssh_key_selection_page.dart';
import 'auto_configure_page.dart';
import 'auto_configure_selection_page.dart';
import 'user_provided_ssh_keys_page.dart';
import 'clone_page.dart';
import 'ssh_key_known_provider_page.dart';

class SettingGitSetupScreen extends StatefulWidget {

    final Func0<void> onCompletedFunction;

    SettingGitSetupScreen(this.onCompletedFunction);

    @override
    State<StatefulWidget> createState() => _SettingGitSetupScreen();
}

enum GitProviderChoice { Unknown, KnownProvider }
enum SetupTypeChoice { Unknown, Manual, Auto }
enum KeyGenerationChoice { Unknown, AutoGenerated, UserProvided }

class _SettingGitSetupScreen extends State<SettingGitSetupScreen> {

    var _pageCount = 1;

    var _pageChoice = [
        GitProviderChoice.Unknown,
        SetupTypeChoice.Unknown
    ];

    var _keyGenerationChoice = KeyGenerationChoice.Unknown;
    var _gitHostType = GitHostType.Unknown;
    var _gitCloneUrl = "git@github.com:antranapp/today-i-learned";
    var gitCloneErrorMessage = "";
    var publicKey = "";

    var pageController = PageController();
    int _currentPageIndex = 0;

    // ignore: missing_return
    Widget _buildPage(BuildContext context, int position) {
        assert(_pageCount >= 1);

        switch (position) {
            case 0: {
                return GitProviderSelectionPage(
                    onKnownGitHost: (GitHostType gitHostType) {
                        setState(() {
                            _gitHostType = gitHostType;
                            _pageChoice[0] = GitProviderChoice.KnownProvider;
                            _pageCount = position + 2;
                            _nextPage();
                        });
                    },
                );
            }
            break;

            case 1: {
                assert(_pageChoice[0] != GitProviderChoice.Unknown);

                return GitAutoConfigureSelectionPage(
                    onDone: (GitHostSetupType setupType) {
                        if (setupType == GitHostSetupType.Manual) {
                            setState(() {
                                _pageCount = position + 2;
                                _pageChoice[1] = SetupTypeChoice.Manual;
                                _nextPage();
                            });
                        } else if (setupType == GitHostSetupType.Auto) {
                            setState(() {
                                _pageCount = position + 2;
                                _pageChoice[1] = SetupTypeChoice.Auto;
                                _nextPage();
                            });
                        }
                    },
                );
            }
            break;

            case 2: {
                assert(_pageChoice[1] != SetupTypeChoice.Unknown);

                if (_pageChoice[1] == SetupTypeChoice.Manual) {
                    return GitCloneUrlKnownProviderPage(
                        doneFunction: (String sshUrl) {
                            setState(() {
                                _pageCount = position + 2;
                                _gitCloneUrl = sshUrl;

                                _nextPage();
                            });
                        },
                        launchCreateUrlPage: _launchCreateRepoPage,
                        gitHostType: _gitHostType,
                        initialValue: _gitCloneUrl,
                    );
                } else if (_pageChoice[1] == SetupTypeChoice.Auto) {
                    return GitAutoConfigurePage(
                        gitHostType: _gitHostType,
                        onDone: (String gitCloneUrl) {
                            setState(() {
                                _gitCloneUrl = gitCloneUrl;
                                _pageCount = position + 2;

                                _nextPage();
                                _startGitClone(context);
                            });
                        },
                    );
                }

                assert(false);
            }
            break;

            case 3: {
                if (_pageChoice[1] == SetupTypeChoice.Manual) {
                    return GitSshKeySelectionPage(
                        onGenerateKeys: () {
                            setState(() {
                                _keyGenerationChoice = KeyGenerationChoice.AutoGenerated;
                                _pageCount = position + 2;

                                _nextPage();
                                _generateSshKey(context);
                            });
                        },
                        onUserProvidedKeys: () {
                            setState(() {
                                _keyGenerationChoice = KeyGenerationChoice.UserProvided;
                                _pageCount = position + 2;
                                _nextPage();
                            });
                        },
                    );
                } else if (_pageChoice[1] == SetupTypeChoice.Auto) {
                    return GitClonePage(errorMessage: gitCloneErrorMessage);
                }

                assert(false);
            }
            break;

            case 4: {
                if (_pageChoice[1] == SetupTypeChoice.Manual) {
                    assert(_keyGenerationChoice != KeyGenerationChoice.Unknown);
                    if (_keyGenerationChoice == KeyGenerationChoice.AutoGenerated) {
                        return GitHostSetupSshKeyKnownProvider(
                            doneFunction: () {
                                setState(() {
                                    _pageCount = 6;

                                    _nextPage();
                                    _startGitClone(context);
                                });
                            },
                            regenerateFunction: () {
                                setState(() {
                                    publicKey = "";
                                });
                                _generateSshKey(context);
                            },
                            publicKey: publicKey,
                            copyKeyFunction: _copyKeyToClipboard,
                            openDeployKeyPage: _launchDeployKeyPage,
                        );
                    } else if (_keyGenerationChoice == KeyGenerationChoice.UserProvided) {
                        return GitUserProvidedSshKeys(
                            doneFunction: (String publicKey, String privateKey) async {
                                await setSshKeys(publicKey: publicKey, privateKey: privateKey);
                                setState(() {
                                    this.publicKey = publicKey;
                                    _pageCount = position + 2;
                                    _nextPage();
                                    _startGitClone(context);
                                });
                            },
                        );
                    }
                }

                assert(false);
            }
            break;

            case 5: {
                if (_pageChoice[1] == SetupTypeChoice.Manual) {
                    return GitClonePage(errorMessage: gitCloneErrorMessage);
                }

                assert(false);
            }
            break;

            default: {
                assert(false);
                return null;
            }
            break;
        }

    }

    @override
    Widget build(BuildContext context) {
        var pageView = PageView.builder(
            controller: pageController,
            itemBuilder: _buildPage,
            itemCount: _pageCount,
            onPageChanged: (int pageNum) {
                setState(() {
                    _currentPageIndex = pageNum;
                    _pageCount = _currentPageIndex + 1;
                });
            },
        );

        var body = Container(
            width: double.infinity,
            height: double.infinity,
            child: Stack(
                alignment: FractionalOffset.bottomCenter,
                children: <Widget>[
                    pageView,
                    DotsIndicator(
                        dotsCount: _pageCount,
                        position: _currentPageIndex,
                        decorator: DotsDecorator(
                            activeColor: Theme.of(context).primaryColorDark,
                        ),
                    ),
                ],
            ),
            padding: const EdgeInsets.all(16.0),
        );

        var scaffold = Scaffold(
            body: Stack(
                children: <Widget>[
                    body,
                    if (Platform.isIOS)
                        SafeArea(
                            child: InkWell(
                                child: Container(
                                    child: const Icon(Icons.arrow_back, size: 32.0),
                                    padding: const EdgeInsets.all(8.0),
                                ),
                                onTap: () => Navigator.of(context).pop(),
                            ),
                        ),
                ],
            ),
        );

        return WillPopScope(
            onWillPop: () async {
                if (_currentPageIndex != 0) {
                    pageController.previousPage(
                        duration: const Duration(milliseconds: 200),
                        curve: Curves.easeIn,
                    );
                    return false;
                }

                return true;
            },
            child: scaffold,
        );
    }

    // Private helpers

    void _nextPage() {
        pageController.nextPage(
            duration: const Duration(milliseconds: 200),
            curve: Curves.easeIn,
        );
    }

    void _startGitClone(BuildContext context) async {
        setState(() {
            gitCloneErrorMessage = "";
        });

        var stateContainer = Provider.of<StateContainer>(context);
        var appState = stateContainer.appState;
        var basePath = appState.gitBaseDirectory;

        // Just in case it was half cloned because of an error
        await _removeExistingClone(basePath);

        String repoPath = p.join(basePath, "journal");
        String error;
        try {
            Log.d("Cloning " + _gitCloneUrl);
            await GitRepo.clone(repoPath, _gitCloneUrl);
        } on GitException catch (e) {
            error = e.cause;
        }

        if (error != null && error.isNotEmpty) {
            setState(() {
                gitCloneErrorMessage = error;
            });
            return;
        }

        //
        // Add a GitIgnore file. This way we always at least have one commit
        // It makes doing a git pull and push easier
        //
        var gitIgnorePath = p.join(repoPath, ".gitignore");
        var ignoreFile = File(gitIgnorePath);
        if (!ignoreFile.existsSync()) {
            ignoreFile.createSync();

            var repo = GitRepo(
                folderPath: repoPath,
                authorName: Settings.instance.gitAuthor,
                authorEmail: Settings.instance.gitAuthorEmail,
            );
            await repo.add('.gitignore');
            await repo.commit(message: "Add gitignore file");
        }

        Navigator.pop(context);
        //widget.onCompletedFunction();
    }

    void _generateSshKey(BuildContext context) {
        if (publicKey.isNotEmpty) {
            return;
        }

        var comment = "GitJournal-" +
            Platform.operatingSystem +
            "-" +
            DateTime.now().toIso8601String().substring(0, 10); // only the date

        generateSSHKeys(comment: comment).then((String publicKey) {
            setState(() {
                this.publicKey = publicKey;
                Log.d("PublicKey: " + publicKey);
                _copyKeyToClipboard(context);
            });
        });
    }

    void _copyKeyToClipboard(BuildContext context) {
        Clipboard.setData(ClipboardData(text: publicKey));
        showSnackbar(context, "Public Key copied to Clipboard");
    }

    void _launchCreateRepoPage() async {
        assert(_gitHostType != GitHostType.Unknown);

        try {
            await launch("https://github.com/new");
        } catch (err, stack) {
            // FIXME: Error handling?
            Log.d("_launchCreateRepoPage: " + err.toString());
            Log.d(stack.toString());
        }
    }

    void _launchDeployKeyPage() async {
        var canLaunch = _gitCloneUrl.startsWith("git@github.com:") ||
            _gitCloneUrl.startsWith("git@gitlab.com:");
        if (!canLaunch) {
            return;
        }

        var lastIndex = _gitCloneUrl.lastIndexOf(".git");
        if (lastIndex == -1) {
            lastIndex = _gitCloneUrl.length;
        }

        var repoName =
        _gitCloneUrl.substring(_gitCloneUrl.lastIndexOf(":") + 1, lastIndex);

        final gitHubUrl = 'https://github.com/' + repoName + '/settings/keys/new';

        try {
            await launch(gitHubUrl);
        } catch (err, stack) {
            Log.d('_launchDeployKeyPage: ' + err.toString());
            Log.d(stack.toString());
        }
    }

    Future _removeExistingClone(String baseDirPath) async {
        var baseDir = Directory(p.join(baseDirPath, "journal"));
        var dotGitDir = Directory(p.join(baseDir.path, ".git"));
        bool exists = dotGitDir.existsSync();
        if (exists) {
            Log.d("Removing " + baseDir.path);
            await baseDir.delete(recursive: true);
            await baseDir.create();
        }
    }
}